2024-06-17T17:23:30.1190957Z ##[group]Run cd $GITHUB_WORKSPACE/ffmpeg-7.0.1
2024-06-17T17:23:30.1191152Z [36;1mcd $GITHUB_WORKSPACE/ffmpeg-7.0.1[0m
2024-06-17T17:23:30.1191259Z [36;1mcat fftools/cmdutils.c[0m
2024-06-17T17:23:30.1249318Z shell: /usr/bin/bash -e {0}
2024-06-17T17:23:30.1249405Z env:
2024-06-17T17:23:30.1249517Z   TT: armv7a-linux-androideabi
2024-06-17T17:23:30.1249683Z   NDK: /usr/local/lib/android/sdk/ndk/25.2.9519653
2024-06-17T17:23:30.1249901Z   PKG_CONFIG_PATH: /home/runner/work/HD/HD/exlibs/lib/pkgconfig:
2024-06-17T17:23:30.1249987Z ##[endgroup]
2024-06-17T17:23:30.1335190Z /*
2024-06-17T17:23:30.1335546Z  * Various utilities for command line tools
2024-06-17T17:23:30.1336132Z  * Copyright (c) 2000-2003 Fabrice Bellard
2024-06-17T17:23:30.1336226Z  *
2024-06-17T17:23:30.1336345Z  * This file is part of FFmpeg.
2024-06-17T17:23:30.1336426Z  *
2024-06-17T17:23:30.1336717Z  * FFmpeg is free software; you can redistribute it and/or
2024-06-17T17:23:30.1336946Z  * modify it under the terms of the GNU Lesser General Public
2024-06-17T17:23:30.1337204Z  * License as published by the Free Software Foundation; either
2024-06-17T17:23:30.1337505Z  * version 2.1 of the License, or (at your option) any later version.
2024-06-17T17:23:30.1337602Z  *
2024-06-17T17:23:30.1337802Z  * FFmpeg is distributed in the hope that it will be useful,
2024-06-17T17:23:30.1338039Z  * but WITHOUT ANY WARRANTY; without even the implied warranty of
2024-06-17T17:23:30.1338362Z  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
2024-06-17T17:23:30.1338808Z  * Lesser General Public License for more details.
2024-06-17T17:23:30.1339116Z  *
2024-06-17T17:23:30.1339535Z  * You should have received a copy of the GNU Lesser General Public
2024-06-17T17:23:30.1339903Z  * License along with FFmpeg; if not, write to the Free Software
2024-06-17T17:23:30.1340531Z  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
2024-06-17T17:23:30.1340615Z  */
2024-06-17T17:23:30.1340622Z 
2024-06-17T17:23:30.1340723Z #include <string.h>
2024-06-17T17:23:30.1340820Z #include <stdint.h>
2024-06-17T17:23:30.1340949Z #include <stdlib.h>
2024-06-17T17:23:30.1341089Z #include <errno.h>
2024-06-17T17:23:30.1341181Z #include <math.h>
2024-06-17T17:23:30.1341186Z 
2024-06-17T17:23:30.1341433Z /* Include only the enabled headers since some compilers (namely, Sun
2024-06-17T17:23:30.1341977Z    Studio) will not omit unused inline functions and create undefined
2024-06-17T17:23:30.1342163Z    references to libraries that are not being built. */
2024-06-17T17:23:30.1342169Z 
2024-06-17T17:23:30.1342258Z #include "config.h"
2024-06-17T17:23:30.1342363Z #include "compat/va_copy.h"
2024-06-17T17:23:30.1342473Z #include "libavformat/avformat.h"
2024-06-17T17:23:30.1342626Z #include "libswscale/swscale.h"
2024-06-17T17:23:30.1342763Z #include "libswscale/version.h"
2024-06-17T17:23:30.1342882Z #include "libswresample/swresample.h"
2024-06-17T17:23:30.1342986Z #include "libavutil/avassert.h"
2024-06-17T17:23:30.1343087Z #include "libavutil/avstring.h"
2024-06-17T17:23:30.1343198Z #include "libavutil/bprint.h"
2024-06-17T17:23:30.1343333Z #include "libavutil/channel_layout.h"
2024-06-17T17:23:30.1343505Z #include "libavutil/display.h"
2024-06-17T17:23:30.1343612Z #include "libavutil/getenv_utf8.h"
2024-06-17T17:23:30.1343723Z #include "libavutil/mathematics.h"
2024-06-17T17:23:30.1343825Z #include "libavutil/imgutils.h"
2024-06-17T17:23:30.1343918Z #include "libavutil/libm.h"
2024-06-17T17:23:30.1344031Z #include "libavutil/parseutils.h"
2024-06-17T17:23:30.1344126Z #include "libavutil/eval.h"
2024-06-17T17:23:30.1344296Z #include "libavutil/dict.h"
2024-06-17T17:23:30.1344406Z #include "libavutil/opt.h"
2024-06-17T17:23:30.1344496Z #include "cmdutils.h"
2024-06-17T17:23:30.1344588Z #include "fopen_utf8.h"
2024-06-17T17:23:30.1344683Z #include "opt_common.h"
2024-06-17T17:23:30.1344769Z #ifdef _WIN32
2024-06-17T17:23:30.1344857Z #include <windows.h>
2024-06-17T17:23:30.1344984Z #include "compat/w32dlfcn.h"
2024-06-17T17:23:30.1345113Z #endif
2024-06-17T17:23:30.1345324Z 
2024-06-17T17:23:30.1345432Z AVDictionary *sws_dict;
2024-06-17T17:23:30.1345533Z AVDictionary *swr_opts;
2024-06-17T17:23:30.1345654Z AVDictionary *format_opts, *codec_opts;
2024-06-17T17:23:30.1345659Z 
2024-06-17T17:23:30.1345767Z int hide_banner = 0;
2024-06-17T17:23:30.1345775Z 
2024-06-17T17:23:30.1345946Z void uninit_opts(void)
2024-06-17T17:23:30.1346025Z {
2024-06-17T17:23:30.1346128Z     av_dict_free(&swr_opts);
2024-06-17T17:23:30.1346222Z     av_dict_free(&sws_dict);
2024-06-17T17:23:30.1346318Z     av_dict_free(&format_opts);
2024-06-17T17:23:30.1346419Z     av_dict_free(&codec_opts);
2024-06-17T17:23:30.1346492Z }
2024-06-17T17:23:30.1346497Z 
2024-06-17T17:23:30.1346839Z void log_callback_help(void *ptr, int level, const char *fmt, va_list vl)
2024-06-17T17:23:30.1346929Z {
2024-06-17T17:23:30.1347033Z     vfprintf(stdout, fmt, vl);
2024-06-17T17:23:30.1347107Z }
2024-06-17T17:23:30.1347112Z 
2024-06-17T17:23:30.1347209Z void init_dynload(void)
2024-06-17T17:23:30.1347287Z {
2024-06-17T17:23:30.1347463Z #if HAVE_SETDLLDIRECTORY && defined(_WIN32)
2024-06-17T17:23:30.1347778Z     /* Calling SetDllDirectory with the empty string (but not NULL) removes the
2024-06-17T17:23:30.1348170Z      * current working directory from the DLL search path as a security pre-caution. */
2024-06-17T17:23:30.1348351Z     SetDllDirectory("");
2024-06-17T17:23:30.1348435Z #endif
2024-06-17T17:23:30.1348509Z }
2024-06-17T17:23:30.1348514Z 
2024-06-17T17:23:30.1348806Z int parse_number(const char *context, const char *numstr, enum OptionType type,
2024-06-17T17:23:30.1348949Z                  double min, double max, double *dst)
2024-06-17T17:23:30.1349052Z {
2024-06-17T17:23:30.1349195Z     char *tail;
2024-06-17T17:23:30.1349291Z     const char *error;
2024-06-17T17:23:30.1349419Z     double d = av_strtod(numstr, &tail);
2024-06-17T17:23:30.1349511Z     if (*tail)
2024-06-17T17:23:30.1349682Z         error = "Expected number for %s but found: %s\n";
2024-06-17T17:23:30.1349787Z     else if (d < min || d > max)
2024-06-17T17:23:30.1350158Z         error = "The value for %s was %s which is not within %f - %f\n";
2024-06-17T17:23:30.1350332Z     else if (type == OPT_TYPE_INT64 && (int64_t)d != d)
2024-06-17T17:23:30.1350489Z         error = "Expected int64 for %s but found %s\n";
2024-06-17T17:23:30.1350661Z     else if (type == OPT_TYPE_INT && (int)d != d)
2024-06-17T17:23:30.1351054Z         error = "Expected int for %s but found %s\n";
2024-06-17T17:23:30.1351142Z     else {
2024-06-17T17:23:30.1351225Z         *dst = d;
2024-06-17T17:23:30.1351311Z         return 0;
2024-06-17T17:23:30.1351391Z     }
2024-06-17T17:23:30.1351397Z 
2024-06-17T17:23:30.1351674Z     av_log(NULL, AV_LOG_FATAL, error, context, numstr, min, max);
2024-06-17T17:23:30.1351783Z     return AVERROR(EINVAL);
2024-06-17T17:23:30.1351870Z }
2024-06-17T17:23:30.1351875Z 
2024-06-17T17:23:30.1352158Z void show_help_options(const OptionDef *options, const char *msg, int req_flags,
2024-06-17T17:23:30.1352260Z                        int rej_flags)
2024-06-17T17:23:30.1352348Z {
2024-06-17T17:23:30.1352449Z     const OptionDef *po;
2024-06-17T17:23:30.1352551Z     int first;
2024-06-17T17:23:30.1352560Z 
2024-06-17T17:23:30.1352703Z     first = 1;
2024-06-17T17:23:30.1352879Z     for (po = options; po->name; po++) {
2024-06-17T17:23:30.1352969Z         char buf[128];
2024-06-17T17:23:30.1352985Z 
2024-06-17T17:23:30.1353177Z         if (((po->flags & req_flags) != req_flags) ||
2024-06-17T17:23:30.1353311Z             (po->flags & rej_flags))
2024-06-17T17:23:30.1353402Z             continue;
2024-06-17T17:23:30.1353407Z 
2024-06-17T17:23:30.1353491Z         if (first) {
2024-06-17T17:23:30.1353587Z             printf("%s\n", msg);
2024-06-17T17:23:30.1353680Z             first = 0;
2024-06-17T17:23:30.1353757Z         }
2024-06-17T17:23:30.1353936Z         av_strlcpy(buf, po->name, sizeof(buf));
2024-06-17T17:23:30.1353943Z 
2024-06-17T17:23:30.1354185Z         if (po->flags & OPT_FLAG_PERSTREAM)
2024-06-17T17:23:30.1354361Z             av_strlcat(buf, "[:<stream_spec>]", sizeof(buf));
2024-06-17T17:23:30.1354681Z         else if (po->flags & OPT_FLAG_SPEC)
2024-06-17T17:23:30.1354832Z             av_strlcat(buf, "[:<spec>]", sizeof(buf));
2024-06-17T17:23:30.1354837Z 
2024-06-17T17:23:30.1354956Z         if (po->argname)
2024-06-17T17:23:30.1355182Z             av_strlcatf(buf, sizeof(buf), " <%s>", po->argname);
2024-06-17T17:23:30.1355192Z 
2024-06-17T17:23:30.1355359Z         printf("-%-17s  %s\n", buf, po->help);
2024-06-17T17:23:30.1355435Z     }
2024-06-17T17:23:30.1355528Z     printf("\n");
2024-06-17T17:23:30.1355602Z }
2024-06-17T17:23:30.1355607Z 
2024-06-17T17:23:30.1355787Z void show_help_children(const AVClass *class, int flags)
2024-06-17T17:23:30.1355867Z {
2024-06-17T17:23:30.1355956Z     void *iter = NULL;
2024-06-17T17:23:30.1356050Z     const AVClass *child;
2024-06-17T17:23:30.1356196Z     if (class->option) {
2024-06-17T17:23:30.1356388Z         av_opt_show2(&class, NULL, flags, 0);
2024-06-17T17:23:30.1356478Z         printf("\n");
2024-06-17T17:23:30.1356572Z     }
2024-06-17T17:23:30.1356577Z 
2024-06-17T17:23:30.1356759Z     while (child = av_opt_child_class_iterate(class, &iter))
2024-06-17T17:23:30.1356874Z         show_help_children(child, flags);
2024-06-17T17:23:30.1356955Z }
2024-06-17T17:23:30.1356960Z 
2024-06-17T17:23:30.1357220Z static const OptionDef *find_option(const OptionDef *po, const char *name)
2024-06-17T17:23:30.1357301Z {
2024-06-17T17:23:30.1357415Z     if (*name == '/')
2024-06-17T17:23:30.1357494Z         name++;
2024-06-17T17:23:30.1357499Z 
2024-06-17T17:23:30.1357617Z     while (po->name) {
2024-06-17T17:23:30.1357709Z         const char *end;
2024-06-17T17:23:30.1357973Z         if (av_strstart(name, po->name, &end) && (!*end || *end == ':'))
2024-06-17T17:23:30.1358060Z             break;
2024-06-17T17:23:30.1358139Z         po++;
2024-06-17T17:23:30.1358215Z     }
2024-06-17T17:23:30.1358302Z     return po;
2024-06-17T17:23:30.1358374Z }
2024-06-17T17:23:30.1358378Z 
2024-06-17T17:23:30.1358657Z /* _WIN32 means using the windows libc - cygwin doesn't define that
2024-06-17T17:23:30.1358875Z  * by default. HAVE_COMMANDLINETOARGVW is true on cygwin, while
2024-06-17T17:23:30.1359169Z  * it doesn't provide the actual command line via GetCommandLineW(). */
2024-06-17T17:23:30.1359320Z #if HAVE_COMMANDLINETOARGVW && defined(_WIN32)
2024-06-17T17:23:30.1359548Z #include <shellapi.h>
2024-06-17T17:23:30.1359650Z /* Will be leaked on exit */
2024-06-17T17:23:30.1359773Z static char** win32_argv_utf8 = NULL;
2024-06-17T17:23:30.1359869Z static int win32_argc = 0;
2024-06-17T17:23:30.1359875Z 
2024-06-17T17:23:30.1359947Z /**
2024-06-17T17:23:30.1360200Z  * Prepare command line arguments for executable.
2024-06-17T17:23:30.1360438Z  * For Windows - perform wide-char to UTF-8 conversion.
2024-06-17T17:23:30.1360636Z  * Input arguments should be main() function arguments.
2024-06-17T17:23:30.1360824Z  * @param argc_ptr Arguments number (including executable)
2024-06-17T17:23:30.1360937Z  * @param argv_ptr Arguments list.
2024-06-17T17:23:30.1361017Z  */
2024-06-17T17:23:30.1361257Z static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)
2024-06-17T17:23:30.1361333Z {
2024-06-17T17:23:30.1361423Z     char *argstr_flat;
2024-06-17T17:23:30.1361518Z     wchar_t **argv_w;
2024-06-17T17:23:30.1361626Z     int i, buffsize = 0, offset = 0;
2024-06-17T17:23:30.1361635Z 
2024-06-17T17:23:30.1361733Z     if (win32_argv_utf8) {
2024-06-17T17:23:30.1361831Z         *argc_ptr = win32_argc;
2024-06-17T17:23:30.1361931Z         *argv_ptr = win32_argv_utf8;
2024-06-17T17:23:30.1362018Z         return;
2024-06-17T17:23:30.1362249Z     }
2024-06-17T17:23:30.1362255Z 
2024-06-17T17:23:30.1362338Z     win32_argc = 0;
2024-06-17T17:23:30.1362551Z     argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);
2024-06-17T17:23:30.1362654Z     if (win32_argc <= 0 || !argv_w)
2024-06-17T17:23:30.1362733Z         return;
2024-06-17T17:23:30.1362738Z 
2024-06-17T17:23:30.1363060Z     /* determine the UTF-8 buffer size (including NULL-termination symbols) */
2024-06-17T17:23:30.1363299Z     for (i = 0; i < win32_argc; i++)
2024-06-17T17:23:30.1363555Z         buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
2024-06-17T17:23:30.1363702Z                                         NULL, 0, NULL, NULL);
2024-06-17T17:23:30.1363708Z 
2024-06-17T17:23:30.1363955Z     win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);
2024-06-17T17:23:30.1364196Z     argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);
2024-06-17T17:23:30.1364290Z     if (!win32_argv_utf8) {
2024-06-17T17:23:30.1364385Z         LocalFree(argv_w);
2024-06-17T17:23:30.1364470Z         return;
2024-06-17T17:23:30.1364544Z     }
2024-06-17T17:23:30.1364549Z 
2024-06-17T17:23:30.1364655Z     for (i = 0; i < win32_argc; i++) {
2024-06-17T17:23:30.1364794Z         win32_argv_utf8[i] = &argstr_flat[offset];
2024-06-17T17:23:30.1365028Z         offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
2024-06-17T17:23:30.1365165Z                                       &argstr_flat[offset],
2024-06-17T17:23:30.1365374Z                                       buffsize - offset, NULL, NULL);
2024-06-17T17:23:30.1365451Z     }
2024-06-17T17:23:30.1365551Z     win32_argv_utf8[i] = NULL;
2024-06-17T17:23:30.1365639Z     LocalFree(argv_w);
2024-06-17T17:23:30.1365647Z 
2024-06-17T17:23:30.1365741Z     *argc_ptr = win32_argc;
2024-06-17T17:23:30.1365843Z     *argv_ptr = win32_argv_utf8;
2024-06-17T17:23:30.1365916Z }
2024-06-17T17:23:30.1365990Z #else
2024-06-17T17:23:30.1366250Z static inline void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)
2024-06-17T17:23:30.1366324Z {
2024-06-17T17:23:30.1366416Z     /* nothing to do */
2024-06-17T17:23:30.1366496Z }
2024-06-17T17:23:30.1366609Z #endif /* HAVE_COMMANDLINETOARGVW */
2024-06-17T17:23:30.1366614Z 
2024-06-17T17:23:30.1366742Z static int opt_has_arg(const OptionDef *o)
2024-06-17T17:23:30.1366823Z {
2024-06-17T17:23:30.1366956Z     if (o->type == OPT_TYPE_BOOL)
2024-06-17T17:23:30.1367059Z         return 0;
2024-06-17T17:23:30.1367272Z     if (o->type == OPT_TYPE_FUNC)
2024-06-17T17:23:30.1367433Z         return !!(o->flags & OPT_FUNC_ARG);
2024-06-17T17:23:30.1367514Z     return 1;
2024-06-17T17:23:30.1367594Z }
2024-06-17T17:23:30.1367599Z 
2024-06-17T17:23:30.1367860Z static int write_option(void *optctx, const OptionDef *po, const char *opt,
2024-06-17T17:23:30.1368288Z                         const char *arg, const OptionDef *defs)
2024-06-17T17:23:30.1368363Z {
2024-06-17T17:23:30.1368681Z     /* new-style options contain an offset into optctx, old-style address of
2024-06-17T17:23:30.1368777Z      * a global var*/
2024-06-17T17:23:30.1368947Z     void *dst = po->flags & OPT_FLAG_OFFSET ?
2024-06-17T17:23:30.1369155Z                 (uint8_t *)optctx + po->u.off : po->u.dst_ptr;
2024-06-17T17:23:30.1369262Z     char *arg_allocated = NULL;
2024-06-17T17:23:30.1369268Z 
2024-06-17T17:23:30.1369376Z     SpecifierOptList *sol = NULL;
2024-06-17T17:23:30.1369458Z     double num;
2024-06-17T17:23:30.1369557Z     int ret = 0;
2024-06-17T17:23:30.1369562Z 
2024-06-17T17:23:30.1369673Z     if (*opt == '/') {
2024-06-17T17:23:30.1369755Z         opt++;
2024-06-17T17:23:30.1369765Z 
2024-06-17T17:23:30.1369914Z         if (po->type == OPT_TYPE_BOOL) {
2024-06-17T17:23:30.1370022Z             av_log(NULL, AV_LOG_FATAL,
2024-06-17T17:23:30.1370331Z                    "Requested to load an argument from file for a bool option '%s'\n",
2024-06-17T17:23:30.1370451Z                    po->name);
2024-06-17T17:23:30.1370551Z             return AVERROR(EINVAL);
2024-06-17T17:23:30.1370635Z         }
2024-06-17T17:23:30.1370641Z 
2024-06-17T17:23:30.1370747Z         arg_allocated = file_read(arg);
2024-06-17T17:23:30.1370842Z         if (!arg_allocated) {
2024-06-17T17:23:30.1370953Z             av_log(NULL, AV_LOG_FATAL,
2024-06-17T17:23:30.1371209Z                    "Error reading the value for option '%s' from file: %s\n",
2024-06-17T17:23:30.1371299Z                    opt, arg);
2024-06-17T17:23:30.1371561Z             return AVERROR(EINVAL);
2024-06-17T17:23:30.1371638Z         }
2024-06-17T17:23:30.1371643Z 
2024-06-17T17:23:30.1371735Z         arg = arg_allocated;
2024-06-17T17:23:30.1371816Z     }
2024-06-17T17:23:30.1371820Z 
2024-06-17T17:23:30.1371960Z     if (po->flags & OPT_FLAG_SPEC) {
2024-06-17T17:23:30.1372103Z         char *p = strchr(opt, ':');
2024-06-17T17:23:30.1372186Z         char *str;
2024-06-17T17:23:30.1372191Z 
2024-06-17T17:23:30.1372275Z         sol = dst;
2024-06-17T17:23:30.1372450Z         ret = GROW_ARRAY(sol->opt, sol->nb_opt);
2024-06-17T17:23:30.1372534Z         if (ret < 0)
2024-06-17T17:23:30.1372621Z             goto finish;
2024-06-17T17:23:30.1372626Z 
2024-06-17T17:23:30.1372747Z         str = av_strdup(p ? p + 1 : "");
2024-06-17T17:23:30.1372831Z         if (!str) {
2024-06-17T17:23:30.1372932Z             ret = AVERROR(ENOMEM);
2024-06-17T17:23:30.1373024Z             goto finish;
2024-06-17T17:23:30.1373101Z         }
2024-06-17T17:23:30.1373279Z         sol->opt[sol->nb_opt - 1].specifier = str;
2024-06-17T17:23:30.1373446Z         dst = &sol->opt[sol->nb_opt - 1].u;
2024-06-17T17:23:30.1373521Z     }
2024-06-17T17:23:30.1373525Z 
2024-06-17T17:23:30.1373691Z     if (po->type == OPT_TYPE_STRING) {
2024-06-17T17:23:30.1373774Z         char *str;
2024-06-17T17:23:30.1373868Z         if (arg_allocated) {
2024-06-17T17:23:30.1373989Z             str           = arg_allocated;
2024-06-17T17:23:30.1374086Z             arg_allocated = NULL;
2024-06-17T17:23:30.1374165Z         } else
2024-06-17T17:23:30.1374264Z             str = av_strdup(arg);
2024-06-17T17:23:30.1374348Z         av_freep(dst);
2024-06-17T17:23:30.1374353Z 
2024-06-17T17:23:30.1374433Z         if (!str) {
2024-06-17T17:23:30.1374534Z             ret = AVERROR(ENOMEM);
2024-06-17T17:23:30.1374618Z             goto finish;
2024-06-17T17:23:30.1374694Z         }
2024-06-17T17:23:30.1374699Z 
2024-06-17T17:23:30.1374794Z         *(char **)dst = str;
2024-06-17T17:23:30.1375066Z     } else if (po->type == OPT_TYPE_BOOL || po->type == OPT_TYPE_INT) {
2024-06-17T17:23:30.1375303Z         ret = parse_number(opt, arg, OPT_TYPE_INT64, INT_MIN, INT_MAX, &num);
2024-06-17T17:23:30.1375396Z         if (ret < 0)
2024-06-17T17:23:30.1375482Z             goto finish;
2024-06-17T17:23:30.1375487Z 
2024-06-17T17:23:30.1375582Z         *(int *)dst = num;
2024-06-17T17:23:30.1375870Z     } else if (po->type == OPT_TYPE_INT64) {
2024-06-17T17:23:30.1376112Z         ret = parse_number(opt, arg, OPT_TYPE_INT64, INT64_MIN, INT64_MAX, &num);
2024-06-17T17:23:30.1376205Z         if (ret < 0)
2024-06-17T17:23:30.1376288Z             goto finish;
2024-06-17T17:23:30.1376292Z 
2024-06-17T17:23:30.1376383Z         *(int64_t *)dst = num;
2024-06-17T17:23:30.1376543Z     } else if (po->type == OPT_TYPE_TIME) {
2024-06-17T17:23:30.1376658Z         ret = av_parse_time(dst, arg, 1);
2024-06-17T17:23:30.1376743Z         if (ret < 0) {
2024-06-17T17:23:30.1376970Z             av_log(NULL, AV_LOG_ERROR, "Invalid duration for option %s: %s\n",
2024-06-17T17:23:30.1377064Z                    opt, arg);
2024-06-17T17:23:30.1377148Z             goto finish;
2024-06-17T17:23:30.1377229Z         }
2024-06-17T17:23:30.1377387Z     } else if (po->type == OPT_TYPE_FLOAT) {
2024-06-17T17:23:30.1377684Z         ret = parse_number(opt, arg, OPT_TYPE_FLOAT, -INFINITY, INFINITY, &num);
2024-06-17T17:23:30.1377781Z         if (ret < 0)
2024-06-17T17:23:30.1377865Z             goto finish;
2024-06-17T17:23:30.1377870Z 
2024-06-17T17:23:30.1377964Z         *(float *)dst = num;
2024-06-17T17:23:30.1378128Z     } else if (po->type == OPT_TYPE_DOUBLE) {
2024-06-17T17:23:30.1378423Z         ret = parse_number(opt, arg, OPT_TYPE_DOUBLE, -INFINITY, INFINITY, &num);
2024-06-17T17:23:30.1378513Z         if (ret < 0)
2024-06-17T17:23:30.1378598Z             goto finish;
2024-06-17T17:23:30.1378603Z 
2024-06-17T17:23:30.1378694Z         *(double *)dst = num;
2024-06-17T17:23:30.1378779Z     } else {
2024-06-17T17:23:30.1379234Z         av_assert0(po->type == OPT_TYPE_FUNC && po->u.func_arg);
2024-06-17T17:23:30.1379402Z 
2024-06-17T17:23:30.1379600Z         ret = po->u.func_arg(optctx, opt, arg);
2024-06-17T17:23:30.1379694Z         if (ret < 0) {
2024-06-17T17:23:30.1379798Z             av_log(NULL, AV_LOG_ERROR,
2024-06-17T17:23:30.1380025Z                    "Failed to set value '%s' for option '%s': %s\n",
2024-06-17T17:23:30.1380152Z                    arg, opt, av_err2str(ret));
2024-06-17T17:23:30.1380237Z             goto finish;
2024-06-17T17:23:30.1380323Z         }
2024-06-17T17:23:30.1380397Z     }
2024-06-17T17:23:30.1380575Z     if (po->flags & OPT_EXIT) {
2024-06-17T17:23:30.1380742Z         ret = AVERROR_EXIT;
2024-06-17T17:23:30.1380830Z         goto finish;
2024-06-17T17:23:30.1380905Z     }
2024-06-17T17:23:30.1380910Z 
2024-06-17T17:23:30.1380997Z     if (sol) {
2024-06-17T17:23:30.1381126Z         sol->type = po->type;
2024-06-17T17:23:30.1381318Z         sol->opt_canon = (po->flags & OPT_HAS_CANON) ?
2024-06-17T17:23:30.1381541Z                          find_option(defs, po->u1.name_canon) : po;
2024-06-17T17:23:30.1381627Z     }
2024-06-17T17:23:30.1381631Z 
2024-06-17T17:23:30.1381708Z finish:
2024-06-17T17:23:30.1381816Z     av_freep(&arg_allocated);
2024-06-17T17:23:30.1381899Z     return ret;
2024-06-17T17:23:30.1381974Z }
2024-06-17T17:23:30.1381986Z 
2024-06-17T17:23:30.1382203Z int parse_option(void *optctx, const char *opt, const char *arg,
2024-06-17T17:23:30.1382320Z                  const OptionDef *options)
2024-06-17T17:23:30.1382405Z {
2024-06-17T17:23:30.1382539Z     static const OptionDef opt_avoptions = {
2024-06-17T17:23:30.1382675Z         .name       = "AVOption passthrough",
2024-06-17T17:23:30.1382783Z         .type       = OPT_TYPE_FUNC,
2024-06-17T17:23:30.1382885Z         .flags      = OPT_FUNC_ARG,
2024-06-17T17:23:30.1382987Z         .u.func_arg = opt_default,
2024-06-17T17:23:30.1383071Z     };
2024-06-17T17:23:30.1383076Z 
2024-06-17T17:23:30.1383173Z     const OptionDef *po;
2024-06-17T17:23:30.1383254Z     int ret;
2024-06-17T17:23:30.1383263Z 
2024-06-17T17:23:30.1383376Z     po = find_option(options, opt);
2024-06-17T17:23:30.1383571Z     if (!po->name && opt[0] == 'n' && opt[1] == 'o') {
2024-06-17T17:23:30.1383715Z         /* handle 'no' bool option */
2024-06-17T17:23:30.1383845Z         po = find_option(options, opt + 2);
2024-06-17T17:23:30.1384232Z         if ((po->name && po->type == OPT_TYPE_BOOL))
2024-06-17T17:23:30.1384330Z             arg = "0";
2024-06-17T17:23:30.1384481Z     } else if (po->type == OPT_TYPE_BOOL)
2024-06-17T17:23:30.1384564Z         arg = "1";
2024-06-17T17:23:30.1384569Z 
2024-06-17T17:23:30.1384681Z     if (!po->name)
2024-06-17T17:23:30.1384777Z         po = &opt_avoptions;
2024-06-17T17:23:30.1384887Z     if (!po->name) {
2024-06-17T17:23:30.1385155Z         av_log(NULL, AV_LOG_ERROR, "Unrecognized option '%s'\n", opt);
2024-06-17T17:23:30.1385254Z         return AVERROR(EINVAL);
2024-06-17T17:23:30.1385332Z     }
2024-06-17T17:23:30.1385440Z     if (opt_has_arg(po) && !arg) {
2024-06-17T17:23:30.1385725Z         av_log(NULL, AV_LOG_ERROR, "Missing argument for option '%s'\n", opt);
2024-06-17T17:23:30.1385822Z         return AVERROR(EINVAL);
2024-06-17T17:23:30.1385904Z     }
2024-06-17T17:23:30.1385909Z 
2024-06-17T17:23:30.1386064Z     ret = write_option(optctx, po, opt, arg, options);
2024-06-17T17:23:30.1386153Z     if (ret < 0)
2024-06-17T17:23:30.1386242Z         return ret;
2024-06-17T17:23:30.1386247Z 
2024-06-17T17:23:30.1386343Z     return opt_has_arg(po);
2024-06-17T17:23:30.1386428Z }
2024-06-17T17:23:30.1386432Z 
2024-06-17T17:23:30.1386704Z int parse_options(void *optctx, int argc, char **argv, const OptionDef *options,
2024-06-17T17:23:30.1386870Z                   int (*parse_arg_function)(void *, const char*))
2024-06-17T17:23:30.1386950Z {
2024-06-17T17:23:30.1387039Z     const char *opt;
2024-06-17T17:23:30.1387160Z     int optindex, handleoptions = 1, ret;
2024-06-17T17:23:30.1387165Z 
2024-06-17T17:23:30.1387437Z     /* perform system-dependent conversions for arguments list */
2024-06-17T17:23:30.1387671Z     prepare_app_arguments(&argc, &argv);
2024-06-17T17:23:30.1387676Z 
2024-06-17T17:23:30.1387767Z     /* parse options */
2024-06-17T17:23:30.1387860Z     optindex = 1;
2024-06-17T17:23:30.1387960Z     while (optindex < argc) {
2024-06-17T17:23:30.1388058Z         opt = argv[optindex++];
2024-06-17T17:23:30.1388073Z 
2024-06-17T17:23:30.1388298Z         if (handleoptions && opt[0] == '-' && opt[1] != '\0') {
2024-06-17T17:23:30.1388463Z             if (opt[1] == '-' && opt[2] == '\0') {
2024-06-17T17:23:30.1388568Z                 handleoptions = 0;
2024-06-17T17:23:30.1388656Z                 continue;
2024-06-17T17:23:30.1388734Z             }
2024-06-17T17:23:30.1388821Z             opt++;
2024-06-17T17:23:30.1388826Z 
2024-06-17T17:23:30.1389052Z             if ((ret = parse_option(optctx, opt, argv[optindex], options)) < 0)
2024-06-17T17:23:30.1389143Z                 return ret;
2024-06-17T17:23:30.1389243Z             optindex += ret;
2024-06-17T17:23:30.1389323Z         } else {
2024-06-17T17:23:30.1389433Z             if (parse_arg_function) {
2024-06-17T17:23:30.1389584Z                 ret = parse_arg_function(optctx, opt);
2024-06-17T17:23:30.1389674Z                 if (ret < 0)
2024-06-17T17:23:30.1389764Z                     return ret;
2024-06-17T17:23:30.1389849Z             }
2024-06-17T17:23:30.1389929Z         }
2024-06-17T17:23:30.1390007Z     }
2024-06-17T17:23:30.1390017Z 
2024-06-17T17:23:30.1390098Z     return 0;
2024-06-17T17:23:30.1390171Z }
2024-06-17T17:23:30.1390177Z 
2024-06-17T17:23:30.1390425Z int parse_optgroup(void *optctx, OptionGroup *g, const OptionDef *defs)
2024-06-17T17:23:30.1390499Z {
2024-06-17T17:23:30.1390582Z     int i, ret;
2024-06-17T17:23:30.1390586Z 
2024-06-17T17:23:30.1390809Z     av_log(NULL, AV_LOG_DEBUG, "Parsing a group of options: %s %s.\n",
2024-06-17T17:23:30.1390950Z            g->group_def->name, g->arg);
2024-06-17T17:23:30.1390955Z 
2024-06-17T17:23:30.1391095Z     for (i = 0; i < g->nb_opts; i++) {
2024-06-17T17:23:30.1391232Z         Option *o = &g->opts[i];
2024-06-17T17:23:30.1391237Z 
2024-06-17T17:23:30.1391364Z         if (g->group_def->flags &&
2024-06-17T17:23:30.1391549Z             !(g->group_def->flags & o->opt->flags)) {
2024-06-17T17:23:30.1391764Z             av_log(NULL, AV_LOG_ERROR, "Option %s (%s) cannot be applied to "
2024-06-17T17:23:30.1392133Z                    "%s %s -- you are trying to apply an input option to an "
2024-06-17T17:23:30.1392338Z                    "output file or vice versa. Move this option before the "
2024-06-17T17:23:30.1392549Z                    "file it belongs to.\n", o->key, o->opt->help,
2024-06-17T17:23:30.1392709Z                    g->group_def->name, g->arg);
2024-06-17T17:23:30.1392815Z             return AVERROR(EINVAL);
2024-06-17T17:23:30.1392892Z         }
2024-06-17T17:23:30.1392897Z 
2024-06-17T17:23:30.1393138Z         av_log(NULL, AV_LOG_DEBUG, "Applying option %s (%s) with argument %s.\n",
2024-06-17T17:23:30.1393302Z                o->key, o->opt->help, o->val);
2024-06-17T17:23:30.1393311Z 
2024-06-17T17:23:30.1393535Z         ret = write_option(optctx, o->opt, o->key, o->val, defs);
2024-06-17T17:23:30.1393630Z         if (ret < 0)
2024-06-17T17:23:30.1393715Z             return ret;
2024-06-17T17:23:30.1393790Z     }
2024-06-17T17:23:30.1393795Z 
2024-06-17T17:23:30.1394035Z     av_log(NULL, AV_LOG_DEBUG, "Successfully parsed a group of options.\n");
2024-06-17T17:23:30.1394040Z 
2024-06-17T17:23:30.1394120Z     return 0;
2024-06-17T17:23:30.1394193Z }
2024-06-17T17:23:30.1394198Z 
2024-06-17T17:23:30.1394426Z int locate_option(int argc, char **argv, const OptionDef *options,
2024-06-17T17:23:30.1394530Z                   const char *optname)
2024-06-17T17:23:30.1394603Z {
2024-06-17T17:23:30.1394704Z     const OptionDef *po;
2024-06-17T17:23:30.1394783Z     int i;
2024-06-17T17:23:30.1394788Z 
2024-06-17T17:23:30.1394893Z     for (i = 1; i < argc; i++) {
2024-06-17T17:23:30.1394999Z         const char *cur_opt = argv[i];
2024-06-17T17:23:30.1395004Z 
2024-06-17T17:23:30.1395242Z         if (*cur_opt++ != '-')
2024-06-17T17:23:30.1395332Z             continue;
2024-06-17T17:23:30.1395337Z 
2024-06-17T17:23:30.1395457Z         po = find_option(options, cur_opt);
2024-06-17T17:23:30.1395678Z         if (!po->name && cur_opt[0] == 'n' && cur_opt[1] == 'o')
2024-06-17T17:23:30.1395825Z             po = find_option(options, cur_opt + 2);
2024-06-17T17:23:30.1395831Z 
2024-06-17T17:23:30.1396020Z         if ((!po->name && !strcmp(cur_opt, optname)) ||
2024-06-17T17:23:30.1396203Z              (po->name && !strcmp(optname, po->name)))
2024-06-17T17:23:30.1396298Z             return i;
2024-06-17T17:23:30.1396302Z 
2024-06-17T17:23:30.1396448Z         if (!po->name || opt_has_arg(po))
2024-06-17T17:23:30.1396533Z             i++;
2024-06-17T17:23:30.1396607Z     }
2024-06-17T17:23:30.1396686Z     return 0;
2024-06-17T17:23:30.1396765Z }
2024-06-17T17:23:30.1396770Z 
2024-06-17T17:23:30.1396961Z static void dump_argument(FILE *report_file, const char *a)
2024-06-17T17:23:30.1397039Z {
2024-06-17T17:23:30.1397142Z     const unsigned char *p;
2024-06-17T17:23:30.1397147Z 
2024-06-17T17:23:30.1397240Z     for (p = a; *p; p++)
2024-06-17T17:23:30.1397465Z         if (!((*p >= '+' && *p <= ':') || (*p >= '@' && *p <= 'Z') ||
2024-06-17T17:23:30.1397645Z               *p == '_' || (*p >= 'a' && *p <= 'z')))
2024-06-17T17:23:30.1397728Z             break;
2024-06-17T17:23:30.1397810Z     if (!*p) {
2024-06-17T17:23:30.1397916Z         fputs(a, report_file);
2024-06-17T17:23:30.1397996Z         return;
2024-06-17T17:23:30.1398071Z     }
2024-06-17T17:23:30.1398202Z     fputc('"', report_file);
2024-06-17T17:23:30.1398299Z     for (p = a; *p; p++) {
2024-06-17T17:23:30.1398504Z         if (*p == '\\' || *p == '"' || *p == '$' || *p == '`')
2024-06-17T17:23:30.1398638Z             fprintf(report_file, "\\%c", *p);
2024-06-17T17:23:30.1398779Z         else if (*p < ' ' || *p > '~')
2024-06-17T17:23:30.1398912Z             fprintf(report_file, "\\x%02x", *p);
2024-06-17T17:23:30.1398994Z         else
2024-06-17T17:23:30.1399096Z             fputc(*p, report_file);
2024-06-17T17:23:30.1399177Z     }
2024-06-17T17:23:30.1399299Z     fputc('"', report_file);
2024-06-17T17:23:30.1399375Z }
2024-06-17T17:23:30.1399380Z 
2024-06-17T17:23:30.1399529Z static void check_options(const OptionDef *po)
2024-06-17T17:23:30.1399742Z {
2024-06-17T17:23:30.1399866Z     while (po->name) {
2024-06-17T17:23:30.1400013Z         if (po->flags & OPT_PERFILE)
2024-06-17T17:23:30.1400288Z             av_assert0(po->flags & (OPT_INPUT | OPT_OUTPUT | OPT_DECODER));
2024-06-17T17:23:30.1400294Z 
2024-06-17T17:23:30.1400434Z         if (po->type == OPT_TYPE_FUNC)
2024-06-17T17:23:30.1400694Z             av_assert0(!(po->flags & (OPT_FLAG_OFFSET | OPT_FLAG_SPEC)));
2024-06-17T17:23:30.1400699Z 
2024-06-17T17:23:30.1400857Z         // OPT_FUNC_ARG can only be ser for OPT_TYPE_FUNC
2024-06-17T17:23:30.1401149Z         av_assert0((po->type == OPT_TYPE_FUNC) || !(po->flags & OPT_FUNC_ARG));
2024-06-17T17:23:30.1401159Z 
2024-06-17T17:23:30.1401238Z         po++;
2024-06-17T17:23:30.1401312Z     }
2024-06-17T17:23:30.1401391Z }
2024-06-17T17:23:30.1401396Z 
2024-06-17T17:23:30.1401628Z void parse_loglevel(int argc, char **argv, const OptionDef *options)
2024-06-17T17:23:30.1401702Z {
2024-06-17T17:23:30.1401891Z     int idx = locate_option(argc, argv, options, "loglevel");
2024-06-17T17:23:30.1401978Z     char *env;
2024-06-17T17:23:30.1401983Z 
2024-06-17T17:23:30.1402078Z     check_options(options);
2024-06-17T17:23:30.1402089Z 
2024-06-17T17:23:30.1402170Z     if (!idx)
2024-06-17T17:23:30.1402320Z         idx = locate_option(argc, argv, options, "v");
2024-06-17T17:23:30.1402423Z     if (idx && argv[idx + 1])
2024-06-17T17:23:30.1402569Z         opt_loglevel(NULL, "loglevel", argv[idx + 1]);
2024-06-17T17:23:30.1402731Z     idx = locate_option(argc, argv, options, "report");
2024-06-17T17:23:30.1402841Z     env = getenv_utf8("FFREPORT");
2024-06-17T17:23:30.1402930Z     if (env || idx) {
2024-06-17T17:23:30.1403031Z         FILE *report_file = NULL;
2024-06-17T17:23:30.1403262Z         init_report(env, &report_file);
2024-06-17T17:23:30.1403354Z         if (report_file) {
2024-06-17T17:23:30.1403434Z             int i;
2024-06-17T17:23:30.1403589Z             fprintf(report_file, "Command line:\n");
2024-06-17T17:23:30.1403700Z             for (i = 0; i < argc; i++) {
2024-06-17T17:23:30.1403839Z                 dump_argument(report_file, argv[i]);
2024-06-17T17:23:30.1404055Z                 fputc(i < argc - 1 ? ' ' : '\n', report_file);
2024-06-17T17:23:30.1404133Z             }
2024-06-17T17:23:30.1404230Z             fflush(report_file);
2024-06-17T17:23:30.1404312Z         }
2024-06-17T17:23:30.1404389Z     }
2024-06-17T17:23:30.1404477Z     freeenv_utf8(env);
2024-06-17T17:23:30.1404658Z     idx = locate_option(argc, argv, options, "hide_banner");
2024-06-17T17:23:30.1404740Z     if (idx)
2024-06-17T17:23:30.1404829Z         hide_banner = 1;
2024-06-17T17:23:30.1404909Z }
2024-06-17T17:23:30.1404913Z 
2024-06-17T17:23:30.1405192Z static const AVOption *opt_find(void *obj, const char *name, const char *unit,
2024-06-17T17:23:30.1405339Z                             int opt_flags, int search_flags)
2024-06-17T17:23:30.1405414Z {
2024-06-17T17:23:30.1405662Z     const AVOption *o = av_opt_find(obj, name, unit, opt_flags, search_flags);
2024-06-17T17:23:30.1405789Z     if(o && !o->flags)
2024-06-17T17:23:30.1405876Z         return NULL;
2024-06-17T17:23:30.1405956Z     return o;
2024-06-17T17:23:30.1406033Z }
2024-06-17T17:23:30.1406038Z 
2024-06-17T17:23:30.1406424Z #define FLAGS (o->type == AV_OPT_TYPE_FLAGS && (arg[0]=='-' || arg[0]=='+')) ? AV_DICT_APPEND : 0
2024-06-17T17:23:30.1406631Z int opt_default(void *optctx, const char *opt, const char *arg)
2024-06-17T17:23:30.1406710Z {
2024-06-17T17:23:30.1406855Z     const AVOption *o;
2024-06-17T17:23:30.1406991Z     int consumed = 0;
2024-06-17T17:23:30.1407099Z     char opt_stripped[128];
2024-06-17T17:23:30.1407185Z     const char *p;
2024-06-17T17:23:30.1407413Z     const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class();
2024-06-17T17:23:30.1407510Z #if CONFIG_SWSCALE
2024-06-17T17:23:30.1407625Z     const AVClass *sc = sws_get_class();
2024-06-17T17:23:30.1407705Z #endif
2024-06-17T17:23:30.1407797Z #if CONFIG_SWRESAMPLE
2024-06-17T17:23:30.1407930Z     const AVClass *swr_class = swr_get_class();
2024-06-17T17:23:30.1408152Z #endif
2024-06-17T17:23:30.1408157Z 
2024-06-17T17:23:30.1408321Z     if (!strcmp(opt, "debug") || !strcmp(opt, "fdebug"))
2024-06-17T17:23:30.1408429Z         av_log_set_level(AV_LOG_DEBUG);
2024-06-17T17:23:30.1408434Z 
2024-06-17T17:23:30.1408583Z     if (!(p = strchr(opt, ':')))
2024-06-17T17:23:30.1408684Z         p = opt + strlen(opt);
2024-06-17T17:23:30.1408982Z     av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));
2024-06-17T17:23:30.1408987Z 
2024-06-17T17:23:30.1409136Z     if ((o = opt_find(&cc, opt_stripped, NULL, 0,
2024-06-17T17:23:30.1409324Z                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||
2024-06-17T17:23:30.1409537Z         ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&
2024-06-17T17:23:30.1409746Z          (o = opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ)))) {
2024-06-17T17:23:30.1409885Z         av_dict_set(&codec_opts, opt, arg, FLAGS);
2024-06-17T17:23:30.1409978Z         consumed = 1;
2024-06-17T17:23:30.1410056Z     }
2024-06-17T17:23:30.1410169Z     if ((o = opt_find(&fc, opt, NULL, 0,
2024-06-17T17:23:30.1410352Z                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {
2024-06-17T17:23:30.1410489Z         av_dict_set(&format_opts, opt, arg, FLAGS);
2024-06-17T17:23:30.1410579Z         if (consumed)
2024-06-17T17:23:30.1410893Z             av_log(NULL, AV_LOG_VERBOSE, "Routing option %s to both codec and muxer layer\n", opt);
2024-06-17T17:23:30.1410981Z         consumed = 1;
2024-06-17T17:23:30.1411055Z     }
2024-06-17T17:23:30.1411149Z #if CONFIG_SWSCALE
2024-06-17T17:23:30.1411300Z     if (!consumed && (o = opt_find(&sc, opt, NULL, 0,
2024-06-17T17:23:30.1411594Z                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {
2024-06-17T17:23:30.1411763Z         if (!strcmp(opt, "srcw") || !strcmp(opt, "srch") ||
2024-06-17T17:23:30.1411921Z             !strcmp(opt, "dstw") || !strcmp(opt, "dsth") ||
2024-06-17T17:23:30.1412127Z             !strcmp(opt, "src_format") || !strcmp(opt, "dst_format")) {
2024-06-17T17:23:30.1412757Z             av_log(NULL, AV_LOG_ERROR, "Directly using swscale dimensions/format options is not supported, please use the -s or -pix_fmt options\n");
2024-06-17T17:23:30.1412861Z             return AVERROR(EINVAL);
2024-06-17T17:23:30.1412951Z         }
2024-06-17T17:23:30.1413084Z         av_dict_set(&sws_dict, opt, arg, FLAGS);
2024-06-17T17:23:30.1413089Z 
2024-06-17T17:23:30.1413175Z         consumed = 1;
2024-06-17T17:23:30.1413256Z     }
2024-06-17T17:23:30.1413330Z #else
2024-06-17T17:23:30.1413468Z     if (!consumed && !strcmp(opt, "sws_flags")) {
2024-06-17T17:23:30.1413760Z         av_log(NULL, AV_LOG_WARNING, "Ignoring %s %s, due to disabled swscale\n", opt, arg);
2024-06-17T17:23:30.1413851Z         consumed = 1;
2024-06-17T17:23:30.1413932Z     }
2024-06-17T17:23:30.1414005Z #endif
2024-06-17T17:23:30.1414096Z #if CONFIG_SWRESAMPLE
2024-06-17T17:23:30.1414269Z     if (!consumed && (o=opt_find(&swr_class, opt, NULL, 0,
2024-06-17T17:23:30.1414467Z                                     AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {
2024-06-17T17:23:30.1414597Z         av_dict_set(&swr_opts, opt, arg, FLAGS);
2024-06-17T17:23:30.1414688Z         consumed = 1;
2024-06-17T17:23:30.1414762Z     }
2024-06-17T17:23:30.1414835Z #endif
2024-06-17T17:23:30.1414840Z 
2024-06-17T17:23:30.1414930Z     if (consumed)
2024-06-17T17:23:30.1415012Z         return 0;
2024-06-17T17:23:30.1415121Z     return AVERROR_OPTION_NOT_FOUND;
2024-06-17T17:23:30.1415203Z }
2024-06-17T17:23:30.1415207Z 
2024-06-17T17:23:30.1415280Z /*
2024-06-17T17:23:30.1415436Z  * Check whether given option is a group separator.
2024-06-17T17:23:30.1415521Z  *
2024-06-17T17:23:30.1415791Z  * @return index of the group definition that matched or -1 if none
2024-06-17T17:23:30.1415867Z  */
2024-06-17T17:23:30.1416142Z static int match_group_separator(const OptionGroupDef *groups, int nb_groups,
2024-06-17T17:23:30.1416263Z                                  const char *opt)
2024-06-17T17:23:30.1416462Z {
2024-06-17T17:23:30.1416543Z     int i;
2024-06-17T17:23:30.1416548Z 
2024-06-17T17:23:30.1416657Z     for (i = 0; i < nb_groups; i++) {
2024-06-17T17:23:30.1416796Z         const OptionGroupDef *p = &groups[i];
2024-06-17T17:23:30.1416957Z         if (p->sep && !strcmp(p->sep, opt))
2024-06-17T17:23:30.1417043Z             return i;
2024-06-17T17:23:30.1417123Z     }
2024-06-17T17:23:30.1417128Z 
2024-06-17T17:23:30.1417231Z     return -1;
2024-06-17T17:23:30.1417308Z }
2024-06-17T17:23:30.1417312Z 
2024-06-17T17:23:30.1417393Z /*
2024-06-17T17:23:30.1417502Z  * Finish parsing an option group.
2024-06-17T17:23:30.1417576Z  *
2024-06-17T17:23:30.1417818Z  * @param group_idx which group definition should this group belong to
2024-06-17T17:23:30.1417980Z  * @param arg argument of the group delimiting option
2024-06-17T17:23:30.1418054Z  */
2024-06-17T17:23:30.1418276Z static int finish_group(OptionParseContext *octx, int group_idx,
2024-06-17T17:23:30.1418385Z                         const char *arg)
2024-06-17T17:23:30.1418462Z {
2024-06-17T17:23:30.1418649Z     OptionGroupList *l = &octx->groups[group_idx];
2024-06-17T17:23:30.1418738Z     OptionGroup *g;
2024-06-17T17:23:30.1418825Z     int ret;
2024-06-17T17:23:30.1418830Z 
2024-06-17T17:23:30.1419329Z     ret = GROW_ARRAY(l->groups, l->nb_groups);
2024-06-17T17:23:30.1419422Z     if (ret < 0)
2024-06-17T17:23:30.1419513Z         return ret;
2024-06-17T17:23:30.1419518Z 
2024-06-17T17:23:30.1419667Z     g = &l->groups[l->nb_groups - 1];
2024-06-17T17:23:30.1419672Z 
2024-06-17T17:23:30.1419805Z     *g             = octx->cur_group;
2024-06-17T17:23:30.1419931Z     g->arg         = arg;
2024-06-17T17:23:30.1420237Z     g->group_def   = l->group_def;
2024-06-17T17:23:30.1420363Z     g->sws_dict    = sws_dict;
2024-06-17T17:23:30.1420492Z     g->swr_opts    = swr_opts;
2024-06-17T17:23:30.1420618Z     g->codec_opts  = codec_opts;
2024-06-17T17:23:30.1420749Z     g->format_opts = format_opts;
2024-06-17T17:23:30.1420764Z 
2024-06-17T17:23:30.1420853Z     codec_opts  = NULL;
2024-06-17T17:23:30.1420945Z     format_opts = NULL;
2024-06-17T17:23:30.1421039Z     sws_dict    = NULL;
2024-06-17T17:23:30.1421126Z     swr_opts    = NULL;
2024-06-17T17:23:30.1421130Z 
2024-06-17T17:23:30.1421339Z     memset(&octx->cur_group, 0, sizeof(octx->cur_group));
2024-06-17T17:23:30.1421345Z 
2024-06-17T17:23:30.1421434Z     return ret;
2024-06-17T17:23:30.1421508Z }
2024-06-17T17:23:30.1421513Z 
2024-06-17T17:23:30.1421585Z /*
2024-06-17T17:23:30.1421761Z  * Add an option instance to currently parsed group.
2024-06-17T17:23:30.1421834Z  */
2024-06-17T17:23:30.1422069Z static int add_opt(OptionParseContext *octx, const OptionDef *opt,
2024-06-17T17:23:30.1422217Z                    const char *key, const char *val)
2024-06-17T17:23:30.1422291Z {
2024-06-17T17:23:30.1422461Z     int global = !(opt->flags & OPT_PERFILE);
2024-06-17T17:23:30.1422730Z     OptionGroup *g = global ? &octx->global_opts : &octx->cur_group;
2024-06-17T17:23:30.1422819Z     int ret;
2024-06-17T17:23:30.1422824Z 
2024-06-17T17:23:30.1422982Z     ret = GROW_ARRAY(g->opts, g->nb_opts);
2024-06-17T17:23:30.1423067Z     if (ret < 0)
2024-06-17T17:23:30.1423150Z         return ret;
2024-06-17T17:23:30.1423155Z 
2024-06-17T17:23:30.1423301Z     g->opts[g->nb_opts - 1].opt = opt;
2024-06-17T17:23:30.1423439Z     g->opts[g->nb_opts - 1].key = key;
2024-06-17T17:23:30.1423571Z     g->opts[g->nb_opts - 1].val = val;
2024-06-17T17:23:30.1423576Z 
2024-06-17T17:23:30.1423662Z     return 0;
2024-06-17T17:23:30.1423736Z }
2024-06-17T17:23:30.1423740Z 
2024-06-17T17:23:30.1423916Z static int init_parse_context(OptionParseContext *octx,
2024-06-17T17:23:30.1424137Z                               const OptionGroupDef *groups, int nb_groups)
2024-06-17T17:23:30.1424212Z {
2024-06-17T17:23:30.1424406Z     static const OptionGroupDef global_group = { "global" };
2024-06-17T17:23:30.1424486Z     int i;
2024-06-17T17:23:30.1424491Z 
2024-06-17T17:23:30.1424593Z     memset(octx, 0, sizeof(*octx));
2024-06-17T17:23:30.1424742Z 
2024-06-17T17:23:30.1425000Z     octx->groups    = av_calloc(nb_groups, sizeof(*octx->groups));
2024-06-17T17:23:30.1425113Z     if (!octx->groups)
2024-06-17T17:23:30.1425213Z         return AVERROR(ENOMEM);
2024-06-17T17:23:30.1425349Z     octx->nb_groups = nb_groups;
2024-06-17T17:23:30.1425354Z 
2024-06-17T17:23:30.1425505Z     for (i = 0; i < octx->nb_groups; i++)
2024-06-17T17:23:30.1425673Z         octx->groups[i].group_def = &groups[i];
2024-06-17T17:23:30.1425685Z 
2024-06-17T17:23:30.1425862Z     octx->global_opts.group_def = &global_group;
2024-06-17T17:23:30.1425999Z     octx->global_opts.arg       = "";
2024-06-17T17:23:30.1426004Z 
2024-06-17T17:23:30.1426095Z     return 0;
2024-06-17T17:23:30.1426169Z }
2024-06-17T17:23:30.1426173Z 
2024-06-17T17:23:30.1426333Z void uninit_parse_context(OptionParseContext *octx)
2024-06-17T17:23:30.1426414Z {
2024-06-17T17:23:30.1426494Z     int i, j;
2024-06-17T17:23:30.1426498Z 
2024-06-17T17:23:30.1426652Z     for (i = 0; i < octx->nb_groups; i++) {
2024-06-17T17:23:30.1426831Z         OptionGroupList *l = &octx->groups[i];
2024-06-17T17:23:30.1426836Z 
2024-06-17T17:23:30.1426991Z         for (j = 0; j < l->nb_groups; j++) {
2024-06-17T17:23:30.1427152Z             av_freep(&l->groups[j].opts);
2024-06-17T17:23:30.1427339Z             av_dict_free(&l->groups[j].codec_opts);
2024-06-17T17:23:30.1427514Z             av_dict_free(&l->groups[j].format_opts);
2024-06-17T17:23:30.1427519Z 
2024-06-17T17:23:30.1427685Z             av_dict_free(&l->groups[j].sws_dict);
2024-06-17T17:23:30.1427840Z             av_dict_free(&l->groups[j].swr_opts);
2024-06-17T17:23:30.1427917Z         }
2024-06-17T17:23:30.1428163Z         av_freep(&l->groups);
2024-06-17T17:23:30.1428238Z     }
2024-06-17T17:23:30.1428360Z     av_freep(&octx->groups);
2024-06-17T17:23:30.1428365Z 
2024-06-17T17:23:30.1428510Z     av_freep(&octx->cur_group.opts);
2024-06-17T17:23:30.1428651Z     av_freep(&octx->global_opts.opts);
2024-06-17T17:23:30.1428657Z 
2024-06-17T17:23:30.1428744Z     uninit_opts();
2024-06-17T17:23:30.1428825Z }
2024-06-17T17:23:30.1428830Z 
2024-06-17T17:23:30.1429076Z int split_commandline(OptionParseContext *octx, int argc, char *argv[],
2024-06-17T17:23:30.1429207Z                       const OptionDef *options,
2024-06-17T17:23:30.1429371Z                       const OptionGroupDef *groups, int nb_groups)
2024-06-17T17:23:30.1429445Z {
2024-06-17T17:23:30.1429531Z     int ret;
2024-06-17T17:23:30.1429620Z     int optindex = 1;
2024-06-17T17:23:30.1429734Z     int dashdash = -2;
2024-06-17T17:23:30.1429739Z 
2024-06-17T17:23:30.1429996Z     /* perform system-dependent conversions for arguments list */
2024-06-17T17:23:30.1430118Z     prepare_app_arguments(&argc, &argv);
2024-06-17T17:23:30.1430123Z 
2024-06-17T17:23:30.1430280Z     ret = init_parse_context(octx, groups, nb_groups);
2024-06-17T17:23:30.1430371Z     if (ret < 0)
2024-06-17T17:23:30.1430453Z         return ret;
2024-06-17T17:23:30.1430458Z 
2024-06-17T17:23:30.1430648Z     av_log(NULL, AV_LOG_DEBUG, "Splitting the commandline.\n");
2024-06-17T17:23:30.1430663Z 
2024-06-17T17:23:30.1430760Z     while (optindex < argc) {
2024-06-17T17:23:30.1430895Z         const char *opt = argv[optindex++], *arg;
2024-06-17T17:23:30.1430999Z         const OptionDef *po;
2024-06-17T17:23:30.1431091Z         int ret, group_idx;
2024-06-17T17:23:30.1431096Z 
2024-06-17T17:23:30.1431334Z         av_log(NULL, AV_LOG_DEBUG, "Reading option '%s' ...", opt);
2024-06-17T17:23:30.1431340Z 
2024-06-17T17:23:30.1431536Z         if (opt[0] == '-' && opt[1] == '-' && !opt[2]) {
2024-06-17T17:23:30.1431636Z             dashdash = optindex;
2024-06-17T17:23:30.1431719Z             continue;
2024-06-17T17:23:30.1431805Z         }
2024-06-17T17:23:30.1431980Z         /* unnamed group separators, e.g. output filename */
2024-06-17T17:23:30.1432201Z         if (opt[0] != '-' || !opt[1] || dashdash+1 == optindex) {
2024-06-17T17:23:30.1432331Z             ret = finish_group(octx, 0, opt);
2024-06-17T17:23:30.1432554Z             if (ret < 0)
2024-06-17T17:23:30.1432648Z                 return ret;
2024-06-17T17:23:30.1432653Z 
2024-06-17T17:23:30.1432863Z             av_log(NULL, AV_LOG_DEBUG, " matched as %s.\n", groups[0].name);
2024-06-17T17:23:30.1432946Z             continue;
2024-06-17T17:23:30.1433030Z         }
2024-06-17T17:23:30.1433112Z         opt++;
2024-06-17T17:23:30.1433117Z 
2024-06-17T17:23:30.1433322Z #define GET_ARG(arg)                                                           \
2024-06-17T17:23:30.1433477Z do {                                                                           \
2024-06-17T17:23:30.1433685Z     arg = argv[optindex++];                                                    \
2024-06-17T17:23:30.1433844Z     if (!arg) {                                                                \
2024-06-17T17:23:30.1434138Z         av_log(NULL, AV_LOG_ERROR, "Missing argument for option '%s'.\n", opt);\
2024-06-17T17:23:30.1434335Z         return AVERROR(EINVAL);                                                \
2024-06-17T17:23:30.1434472Z     }                                                                          \
2024-06-17T17:23:30.1434554Z } while (0)
2024-06-17T17:23:30.1434560Z 
2024-06-17T17:23:30.1434725Z         /* named group separators, e.g. -i */
2024-06-17T17:23:30.1434925Z         group_idx = match_group_separator(groups, nb_groups, opt);
2024-06-17T17:23:30.1435021Z         if (group_idx >= 0) {
2024-06-17T17:23:30.1435110Z             GET_ARG(arg);
2024-06-17T17:23:30.1435259Z             ret = finish_group(octx, group_idx, arg);
2024-06-17T17:23:30.1435347Z             if (ret < 0)
2024-06-17T17:23:30.1435435Z                 return ret;
2024-06-17T17:23:30.1435550Z 
2024-06-17T17:23:30.1435837Z             av_log(NULL, AV_LOG_DEBUG, " matched as %s with argument '%s'.\n",
2024-06-17T17:23:30.1435963Z                    groups[group_idx].name, arg);
2024-06-17T17:23:30.1436054Z             continue;
2024-06-17T17:23:30.1436132Z         }
2024-06-17T17:23:30.1436137Z 
2024-06-17T17:23:30.1436236Z         /* normal options */
2024-06-17T17:23:30.1436355Z         po = find_option(options, opt);
2024-06-17T17:23:30.1436469Z         if (po->name) {
2024-06-17T17:23:30.1436607Z             if (po->flags & OPT_EXIT) {
2024-06-17T17:23:30.1436781Z                 /* optional argument, e.g. -h */
2024-06-17T17:23:30.1436887Z                 arg = argv[optindex++];
2024-06-17T17:23:30.1437001Z             } else if (opt_has_arg(po)) {
2024-06-17T17:23:30.1437099Z                 GET_ARG(arg);
2024-06-17T17:23:30.1437179Z             } else {
2024-06-17T17:23:30.1437266Z                 arg = "1";
2024-06-17T17:23:30.1437350Z             }
2024-06-17T17:23:30.1437355Z 
2024-06-17T17:23:30.1437484Z             ret = add_opt(octx, po, opt, arg);
2024-06-17T17:23:30.1437571Z             if (ret < 0)
2024-06-17T17:23:30.1437664Z                 return ret;
2024-06-17T17:23:30.1437669Z 
2024-06-17T17:23:30.1437935Z             av_log(NULL, AV_LOG_DEBUG, " matched as option '%s' (%s) with "
2024-06-17T17:23:30.1438153Z                    "argument '%s'.\n", po->name, po->help, arg);
2024-06-17T17:23:30.1438241Z             continue;
2024-06-17T17:23:30.1438329Z         }
2024-06-17T17:23:30.1438335Z 
2024-06-17T17:23:30.1438430Z         /* AVOptions */
2024-06-17T17:23:30.1438525Z         if (argv[optindex]) {
2024-06-17T17:23:30.1438677Z             ret = opt_default(NULL, opt, argv[optindex]);
2024-06-17T17:23:30.1438771Z             if (ret >= 0) {
2024-06-17T17:23:30.1439020Z                 av_log(NULL, AV_LOG_DEBUG, " matched as AVOption '%s' with "
2024-06-17T17:23:30.1439216Z                        "argument '%s'.\n", opt, argv[optindex]);
2024-06-17T17:23:30.1439314Z                 optindex++;
2024-06-17T17:23:30.1439403Z                 continue;
2024-06-17T17:23:30.1439554Z             } else if (ret != AVERROR_OPTION_NOT_FOUND) {
2024-06-17T17:23:30.1439806Z                 av_log(NULL, AV_LOG_ERROR, "Error parsing option '%s' "
2024-06-17T17:23:30.1440016Z                        "with argument '%s'.\n", opt, argv[optindex]);
2024-06-17T17:23:30.1440231Z                 return ret;
2024-06-17T17:23:30.1440311Z             }
2024-06-17T17:23:30.1440387Z         }
2024-06-17T17:23:30.1440392Z 
2024-06-17T17:23:30.1440537Z         /* boolean -nofoo options */
2024-06-17T17:23:30.1440695Z         if (opt[0] == 'n' && opt[1] == 'o' &&
2024-06-17T17:23:30.1440829Z             (po = find_option(options, opt + 2)) &&
2024-06-17T17:23:30.1441018Z             po->name && po->type == OPT_TYPE_BOOL) {
2024-06-17T17:23:30.1441146Z             ret = add_opt(octx, po, opt, "0");
2024-06-17T17:23:30.1441233Z             if (ret < 0)
2024-06-17T17:23:30.1441326Z                 return ret;
2024-06-17T17:23:30.1441335Z 
2024-06-17T17:23:30.1441592Z             av_log(NULL, AV_LOG_DEBUG, " matched as option '%s' (%s) with "
2024-06-17T17:23:30.1441778Z                    "argument 0.\n", po->name, po->help);
2024-06-17T17:23:30.1441872Z             continue;
2024-06-17T17:23:30.1441949Z         }
2024-06-17T17:23:30.1441958Z 
2024-06-17T17:23:30.1442221Z         av_log(NULL, AV_LOG_ERROR, "Unrecognized option '%s'.\n", opt);
2024-06-17T17:23:30.1442345Z         return AVERROR_OPTION_NOT_FOUND;
2024-06-17T17:23:30.1442420Z     }
2024-06-17T17:23:30.1442424Z 
2024-06-17T17:23:30.1442657Z     if (octx->cur_group.nb_opts || codec_opts || format_opts)
2024-06-17T17:23:30.1442859Z         av_log(NULL, AV_LOG_WARNING, "Trailing option(s) found in the "
2024-06-17T17:23:30.1442981Z                "command: may be ignored.\n");
2024-06-17T17:23:30.1442986Z 
2024-06-17T17:23:30.1443220Z     av_log(NULL, AV_LOG_DEBUG, "Finished splitting the commandline.\n");
2024-06-17T17:23:30.1443225Z 
2024-06-17T17:23:30.1443421Z     return 0;
2024-06-17T17:23:30.1443500Z }
2024-06-17T17:23:30.1443504Z 
2024-06-17T17:23:30.1443595Z int read_yesno(void)
2024-06-17T17:23:30.1443670Z {
2024-06-17T17:23:30.1443765Z     int c = getchar();
2024-06-17T17:23:30.1443914Z     int yesno = (av_toupper(c) == 'Y');
2024-06-17T17:23:30.1443919Z 
2024-06-17T17:23:30.1444051Z     while (c != '\n' && c != EOF)
2024-06-17T17:23:30.1444145Z         c = getchar();
2024-06-17T17:23:30.1444149Z 
2024-06-17T17:23:30.1444233Z     return yesno;
2024-06-17T17:23:30.1444306Z }
2024-06-17T17:23:30.1444310Z 
2024-06-17T17:23:30.1444504Z FILE *get_preset_file(char *filename, size_t filename_size,
2024-06-17T17:23:30.1444651Z                       const char *preset_name, int is_path,
2024-06-17T17:23:30.1444768Z                       const char *codec_name)
2024-06-17T17:23:30.1444848Z {
2024-06-17T17:23:30.1444936Z     FILE *f = NULL;
2024-06-17T17:23:30.1445019Z     int i;
2024-06-17T17:23:30.1445153Z #if HAVE_GETMODULEHANDLE && defined(_WIN32)
2024-06-17T17:23:30.1445250Z     char *datadir = NULL;
2024-06-17T17:23:30.1445333Z #endif
2024-06-17T17:23:30.1445449Z     char *env_home = getenv_utf8("HOME");
2024-06-17T17:23:30.1445626Z     char *env_ffmpeg_datadir = getenv_utf8("FFMPEG_DATADIR");
2024-06-17T17:23:30.1445770Z     const char *base[3] = { env_ffmpeg_datadir,
2024-06-17T17:23:30.1446035Z                             env_home,   /* index=1(HOME) is special: search in a .ffmpeg subfolder */
2024-06-17T17:23:30.1446156Z                             FFMPEG_DATADIR, };
2024-06-17T17:23:30.1446161Z 
2024-06-17T17:23:30.1446255Z     if (is_path) {
2024-06-17T17:23:30.1446415Z         av_strlcpy(filename, preset_name, filename_size);
2024-06-17T17:23:30.1446523Z         f = fopen_utf8(filename, "r");
2024-06-17T17:23:30.1446608Z     } else {
2024-06-17T17:23:30.1446735Z #if HAVE_GETMODULEHANDLE && defined(_WIN32)
2024-06-17T17:23:30.1446886Z         wchar_t *datadir_w = get_module_filename(NULL);
2024-06-17T17:23:30.1446979Z         base[2] = NULL;
2024-06-17T17:23:30.1446988Z 
2024-06-17T17:23:30.1447111Z         if (wchartoutf8(datadir_w, &datadir))
2024-06-17T17:23:30.1447208Z             datadir = NULL;
2024-06-17T17:23:30.1447298Z         av_free(datadir_w);
2024-06-17T17:23:30.1447303Z 
2024-06-17T17:23:30.1447384Z         if (datadir)
2024-06-17T17:23:30.1447466Z         {
2024-06-17T17:23:30.1447666Z             char *ls;
2024-06-17T17:23:30.1447778Z             for (ls = datadir; *ls; ls++)
2024-06-17T17:23:30.1447931Z                 if (*ls == '\\') *ls = '/';
2024-06-17T17:23:30.1447936Z 
2024-06-17T17:23:30.1448085Z             if (ls = strrchr(datadir, '/'))
2024-06-17T17:23:30.1448161Z             {
2024-06-17T17:23:30.1448347Z                 ptrdiff_t datadir_len = ls - datadir;
2024-06-17T17:23:30.1448558Z                 size_t desired_size = datadir_len + strlen("/ffpresets") + 1;
2024-06-17T17:23:30.1448695Z                 char *new_datadir = av_realloc_array(
2024-06-17T17:23:30.1448845Z                     datadir, desired_size, sizeof *datadir);
2024-06-17T17:23:30.1448946Z                 if (new_datadir) {
2024-06-17T17:23:30.1449059Z                     datadir = new_datadir;
2024-06-17T17:23:30.1449176Z                     datadir[datadir_len] = 0;
2024-06-17T17:23:30.1449460Z                     strncat(datadir, "/ffpresets",  desired_size - 1 - datadir_len);
2024-06-17T17:23:30.1449567Z                     base[2] = datadir;
2024-06-17T17:23:30.1449646Z                 }
2024-06-17T17:23:30.1449722Z             }
2024-06-17T17:23:30.1449805Z         }
2024-06-17T17:23:30.1449879Z #endif
2024-06-17T17:23:30.1449984Z         for (i = 0; i < 3 && !f; i++) {
2024-06-17T17:23:30.1450077Z             if (!base[i])
2024-06-17T17:23:30.1450161Z                 continue;
2024-06-17T17:23:30.1450376Z             snprintf(filename, filename_size, "%s%s/%s.ffpreset", base[i],
2024-06-17T17:23:30.1450522Z                      i != 1 ? "" : "/.ffmpeg", preset_name);
2024-06-17T17:23:30.1450636Z             f = fopen_utf8(filename, "r");
2024-06-17T17:23:30.1450877Z             if (!f && codec_name) {
2024-06-17T17:23:30.1451013Z                 snprintf(filename, filename_size,
2024-06-17T17:23:30.1451172Z                          "%s%s/%s-%s.ffpreset",
2024-06-17T17:23:30.1451339Z                          base[i], i != 1 ? "" : "/.ffmpeg", codec_name,
2024-06-17T17:23:30.1451440Z                          preset_name);
2024-06-17T17:23:30.1451560Z                 f = fopen_utf8(filename, "r");
2024-06-17T17:23:30.1451644Z             }
2024-06-17T17:23:30.1451719Z         }
2024-06-17T17:23:30.1451792Z     }
2024-06-17T17:23:30.1451797Z 
2024-06-17T17:23:30.1451930Z #if HAVE_GETMODULEHANDLE && defined(_WIN32)
2024-06-17T17:23:30.1452016Z     av_free(datadir);
2024-06-17T17:23:30.1452089Z #endif
2024-06-17T17:23:30.1452203Z     freeenv_utf8(env_ffmpeg_datadir);
2024-06-17T17:23:30.1452294Z     freeenv_utf8(env_home);
2024-06-17T17:23:30.1452374Z     return f;
2024-06-17T17:23:30.1452452Z }
2024-06-17T17:23:30.1452457Z 
2024-06-17T17:23:30.1452726Z int check_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
2024-06-17T17:23:30.1452804Z {
2024-06-17T17:23:30.1452990Z     int ret = avformat_match_stream_specifier(s, st, spec);
2024-06-17T17:23:30.1453073Z     if (ret < 0)
2024-06-17T17:23:30.1453282Z         av_log(s, AV_LOG_ERROR, "Invalid stream specifier: %s.\n", spec);
2024-06-17T17:23:30.1453380Z     return ret;
2024-06-17T17:23:30.1453453Z }
2024-06-17T17:23:30.1453458Z 
2024-06-17T17:23:30.1453706Z int filter_codec_opts(const AVDictionary *opts, enum AVCodecID codec_id,
2024-06-17T17:23:30.1453904Z                       AVFormatContext *s, AVStream *st, const AVCodec *codec,
2024-06-17T17:23:30.1454011Z                       AVDictionary **dst)
2024-06-17T17:23:30.1454089Z {
2024-06-17T17:23:30.1454189Z     AVDictionary    *ret = NULL;
2024-06-17T17:23:30.1454302Z     const AVDictionaryEntry *t = NULL;
2024-06-17T17:23:30.1454542Z     int            flags = s->oformat ? AV_OPT_FLAG_ENCODING_PARAM
2024-06-17T17:23:30.1454689Z                                       : AV_OPT_FLAG_DECODING_PARAM;
2024-06-17T17:23:30.1454787Z     char          prefix = 0;
2024-06-17T17:23:30.1454927Z     const AVClass    *cc = avcodec_get_class();
2024-06-17T17:23:30.1454932Z 
2024-06-17T17:23:30.1455012Z     if (!codec)
2024-06-17T17:23:30.1455251Z         codec            = s->oformat ? avcodec_find_encoder(codec_id)
2024-06-17T17:23:30.1455517Z                                       : avcodec_find_decoder(codec_id);
2024-06-17T17:23:30.1455523Z 
2024-06-17T17:23:30.1455668Z     switch (st->codecpar->codec_type) {
2024-06-17T17:23:30.1455773Z     case AVMEDIA_TYPE_VIDEO:
2024-06-17T17:23:30.1455886Z         prefix  = 'v';
2024-06-17T17:23:30.1456002Z         flags  |= AV_OPT_FLAG_VIDEO_PARAM;
2024-06-17T17:23:30.1456087Z         break;
2024-06-17T17:23:30.1456181Z     case AVMEDIA_TYPE_AUDIO:
2024-06-17T17:23:30.1456295Z         prefix  = 'a';
2024-06-17T17:23:30.1456414Z         flags  |= AV_OPT_FLAG_AUDIO_PARAM;
2024-06-17T17:23:30.1456494Z         break;
2024-06-17T17:23:30.1456597Z     case AVMEDIA_TYPE_SUBTITLE:
2024-06-17T17:23:30.1456716Z         prefix  = 's';
2024-06-17T17:23:30.1456839Z         flags  |= AV_OPT_FLAG_SUBTITLE_PARAM;
2024-06-17T17:23:30.1456915Z         break;
2024-06-17T17:23:30.1456994Z     }
2024-06-17T17:23:30.1456999Z 
2024-06-17T17:23:30.1457116Z     while (t = av_dict_iterate(opts, t)) {
2024-06-17T17:23:30.1457230Z         const AVClass *priv_class;
2024-06-17T17:23:30.1457369Z         char *p = strchr(t->key, ':');
2024-06-17T17:23:30.1457374Z 
2024-06-17T17:23:30.1457519Z         /* check stream specification in opt name */
2024-06-17T17:23:30.1457607Z         if (p) {
2024-06-17T17:23:30.1457767Z             int err = check_stream_specifier(s, st, p + 1);
2024-06-17T17:23:30.1457857Z             if (err < 0) {
2024-06-17T17:23:30.1457963Z                 av_dict_free(&ret);
2024-06-17T17:23:30.1458053Z                 return err;
2024-06-17T17:23:30.1458147Z             } else if (!err)
2024-06-17T17:23:30.1458237Z                 continue;
2024-06-17T17:23:30.1458371Z 
2024-06-17T17:23:30.1458453Z             *p = 0;
2024-06-17T17:23:30.1458528Z         }
2024-06-17T17:23:30.1458533Z 
2024-06-17T17:23:30.1459086Z         if (av_opt_find(&cc, t->key, NULL, flags, AV_OPT_SEARCH_FAKE_OBJ) ||
2024-06-17T17:23:30.1459184Z             !codec ||
2024-06-17T17:23:30.1459373Z             ((priv_class = codec->priv_class) &&
2024-06-17T17:23:30.1459635Z              av_opt_find(&priv_class, t->key, NULL, flags,
2024-06-17T17:23:30.1459778Z                          AV_OPT_SEARCH_FAKE_OBJ)))
2024-06-17T17:23:30.1459959Z             av_dict_set(&ret, t->key, t->value, 0);
2024-06-17T17:23:30.1460101Z         else if (t->key[0] == prefix &&
2024-06-17T17:23:30.1460287Z                  av_opt_find(&cc, t->key + 1, NULL, flags,
2024-06-17T17:23:30.1460423Z                              AV_OPT_SEARCH_FAKE_OBJ))
2024-06-17T17:23:30.1460602Z             av_dict_set(&ret, t->key + 1, t->value, 0);
2024-06-17T17:23:30.1460608Z 
2024-06-17T17:23:30.1460701Z         if (p)
2024-06-17T17:23:30.1460815Z             *p = ':';
2024-06-17T17:23:30.1460889Z     }
2024-06-17T17:23:30.1460894Z 
2024-06-17T17:23:30.1460975Z     *dst = ret;
2024-06-17T17:23:30.1461062Z     return 0;
2024-06-17T17:23:30.1461134Z }
2024-06-17T17:23:30.1461139Z 
2024-06-17T17:23:30.1461301Z int setup_find_stream_info_opts(AVFormatContext *s,
2024-06-17T17:23:30.1461441Z                                 AVDictionary *codec_opts,
2024-06-17T17:23:30.1461568Z                                 AVDictionary ***dst)
2024-06-17T17:23:30.1461647Z {
2024-06-17T17:23:30.1461727Z     int ret;
2024-06-17T17:23:30.1461820Z     AVDictionary **opts;
2024-06-17T17:23:30.1461825Z 
2024-06-17T17:23:30.1461910Z     *dst = NULL;
2024-06-17T17:23:30.1461915Z 
2024-06-17T17:23:30.1462027Z     if (!s->nb_streams)
2024-06-17T17:23:30.1462108Z         return 0;
2024-06-17T17:23:30.1462113Z 
2024-06-17T17:23:30.1462299Z     opts = av_calloc(s->nb_streams, sizeof(*opts));
2024-06-17T17:23:30.1462379Z     if (!opts)
2024-06-17T17:23:30.1462479Z         return AVERROR(ENOMEM);
2024-06-17T17:23:30.1462492Z 
2024-06-17T17:23:30.1462654Z     for (int i = 0; i < s->nb_streams; i++) {
2024-06-17T17:23:30.1462939Z         ret = filter_codec_opts(codec_opts, s->streams[i]->codecpar->codec_id,
2024-06-17T17:23:30.1463137Z                                 s, s->streams[i], NULL, &opts[i]);
2024-06-17T17:23:30.1463390Z         if (ret < 0)
2024-06-17T17:23:30.1463473Z             goto fail;
2024-06-17T17:23:30.1463554Z     }
2024-06-17T17:23:30.1463634Z     *dst = opts;
2024-06-17T17:23:30.1463712Z     return 0;
2024-06-17T17:23:30.1463792Z fail:
2024-06-17T17:23:30.1463950Z     for (int i = 0; i < s->nb_streams; i++)
2024-06-17T17:23:30.1464046Z         av_dict_free(&opts[i]);
2024-06-17T17:23:30.1464139Z     av_freep(&opts);
2024-06-17T17:23:30.1464220Z     return ret;
2024-06-17T17:23:30.1464291Z }
2024-06-17T17:23:30.1464297Z 
2024-06-17T17:23:30.1464522Z int grow_array(void **array, int elem_size, int *size, int new_size)
2024-06-17T17:23:30.1464600Z {
2024-06-17T17:23:30.1464717Z     if (new_size >= INT_MAX / elem_size) {
2024-06-17T17:23:30.1464871Z         av_log(NULL, AV_LOG_ERROR, "Array too big.\n");
2024-06-17T17:23:30.1464966Z         return AVERROR(ERANGE);
2024-06-17T17:23:30.1465038Z     }
2024-06-17T17:23:30.1465137Z     if (*size < new_size) {
2024-06-17T17:23:30.1465337Z         uint8_t *tmp = av_realloc_array(*array, new_size, elem_size);
2024-06-17T17:23:30.1465424Z         if (!tmp)
2024-06-17T17:23:30.1465524Z             return AVERROR(ENOMEM);
2024-06-17T17:23:30.1465779Z         memset(tmp + *size*elem_size, 0, (new_size-*size) * elem_size);
2024-06-17T17:23:30.1465875Z         *size = new_size;
2024-06-17T17:23:30.1465963Z         *array = tmp;
2024-06-17T17:23:30.1466042Z         return 0;
2024-06-17T17:23:30.1466122Z     }
2024-06-17T17:23:30.1466202Z     return 0;
2024-06-17T17:23:30.1466275Z }
2024-06-17T17:23:30.1466279Z 
2024-06-17T17:23:30.1466505Z void *allocate_array_elem(void *ptr, size_t elem_size, int *nb_elems)
2024-06-17T17:23:30.1466717Z {
2024-06-17T17:23:30.1466802Z     void *new_elem;
2024-06-17T17:23:30.1466807Z 
2024-06-17T17:23:30.1466941Z     if (!(new_elem = av_mallocz(elem_size)) ||
2024-06-17T17:23:30.1467109Z         av_dynarray_add_nofree(ptr, nb_elems, new_elem) < 0)
2024-06-17T17:23:30.1467193Z         return NULL;
2024-06-17T17:23:30.1467289Z     return new_elem;
2024-06-17T17:23:30.1467360Z }
2024-06-17T17:23:30.1467365Z 
2024-06-17T17:23:30.1467516Z double get_rotation(const int32_t *displaymatrix)
2024-06-17T17:23:30.1467594Z {
2024-06-17T17:23:30.1467681Z     double theta = 0;
2024-06-17T17:23:30.1467776Z     if (displaymatrix)
2024-06-17T17:23:30.1468004Z         theta = -round(av_display_rotation_get(displaymatrix));
2024-06-17T17:23:30.1468010Z 
2024-06-17T17:23:30.1468171Z     theta -= 360*floor(theta/360 + 0.9/360);
2024-06-17T17:23:30.1468177Z 
2024-06-17T17:23:30.1468342Z     if (fabs(theta - 90*round(theta/90)) > 2)
2024-06-17T17:23:30.1468508Z         av_log(NULL, AV_LOG_WARNING, "Odd rotation angle.\n"
2024-06-17T17:23:30.1468657Z                "If you want to help, upload a sample "
2024-06-17T17:23:30.1468875Z                "of this file to https://streams.videolan.org/upload/ "
2024-06-17T17:23:30.1469192Z                "and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)");
2024-06-17T17:23:30.1469202Z 
2024-06-17T17:23:30.1469290Z     return theta;
2024-06-17T17:23:30.1469362Z }
2024-06-17T17:23:30.1469367Z 
2024-06-17T17:23:30.1469480Z /* read file contents into a string */
2024-06-17T17:23:30.1469596Z char *file_read(const char *filename)
2024-06-17T17:23:30.1469669Z {
2024-06-17T17:23:30.1469769Z     AVIOContext *pb      = NULL;
2024-06-17T17:23:30.1469940Z     int ret = avio_open(&pb, filename, AVIO_FLAG_READ);
2024-06-17T17:23:30.1470032Z     AVBPrint bprint;
2024-06-17T17:23:30.1470113Z     char *str;
2024-06-17T17:23:30.1470118Z 
2024-06-17T17:23:30.1470206Z     if (ret < 0) {
2024-06-17T17:23:30.1470420Z         av_log(NULL, AV_LOG_ERROR, "Error opening file %s.\n", filename);
2024-06-17T17:23:30.1470507Z         return NULL;
2024-06-17T17:23:30.1470586Z     }
2024-06-17T17:23:30.1470590Z 
2024-06-17T17:23:30.1470756Z     av_bprint_init(&bprint, 0, AV_BPRINT_SIZE_UNLIMITED);
2024-06-17T17:23:30.1470909Z     ret = avio_read_to_bprint(pb, &bprint, SIZE_MAX);
2024-06-17T17:23:30.1471123Z     avio_closep(&pb);
2024-06-17T17:23:30.1471205Z     if (ret < 0) {
2024-06-17T17:23:30.1471328Z         av_bprint_finalize(&bprint, NULL);
2024-06-17T17:23:30.1471410Z         return NULL;
2024-06-17T17:23:30.1471483Z     }
2024-06-17T17:23:30.1471619Z     ret = av_bprint_finalize(&bprint, &str);
2024-06-17T17:23:30.1471700Z     if (ret < 0)
2024-06-17T17:23:30.1471781Z         return NULL;
2024-06-17T17:23:30.1471868Z     return str;
2024-06-17T17:23:30.1471940Z }
